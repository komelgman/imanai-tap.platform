## ADR-001: Selecting the Initial Microservice Stack

**Date:** November 16, 2025

**Status:** Approved

### 1. Context

We are an early-stage startup. Our primary goal is **rapid Time-to-Market (TTM)**. The development team does not have dedicated DevOps specialists. All infrastructure must be as simple as possible, allowing any developer to run and test the entire system locally using **Docker Compose**. At the same time, we want to establish foundational architectural patterns (Service Discovery, Centralized Config) from the outset to avoid the growing pains of a "monolith" and simplify future migration to a more mature platform (e.g., Kubernetes).

### 2. Decision

We have decided to use the "classic" **Spring Cloud** suite as our "mini-platform," deployed as standard Spring Boot applications:

1.  **Service Discovery:** `Spring Cloud Netflix Eureka`
2.  **Centralized Configuration:** `Spring Cloud Config Server` (using a Git repository as the backend)
3.  **API Gateway:** `Spring Cloud Gateway`

These three services will run as regular containers in our `docker-compose.yml` alongside our business microservices.

### 3. Rationale

* **Low Barrier to Entry:** These are "just" three more Spring Boot applications. Developers familiar with Spring can maintain this infrastructure without any knowledge of Kubernetes, Consul, or Istio.
* **Self-Contained:** The stack is fully self-sufficient. It provides all necessary "cloud" patterns (routing, discovery, configuration) "out of the box" and works perfectly within `docker-compose`.
* **Seamless Integration:** The components (`Gateway`, `Config`, `Eureka`) are designed to work together seamlessly. For example, `Spring Cloud Gateway` automatically uses `Eureka` to discover downstream services.
* **Clear Migration Path:** We are "abstracting" the infrastructure tasks. Our business services simply use annotations (e.g., `@EnableDiscoveryClient`) and standard interfaces. In the future, we can replace the *implementation* (Eureka, Config Server) with K8s-native equivalents **without changing the business logic**.

### 4. Consequences

* **Positive:**
    * Maximally fast start for the team.
    * The entire system can be easily run locally with a single command (`docker-compose up`).
    * A unified technology stack (Java/Spring) for both infrastructure and business logic.
    * We avoid "hardcoding" IP addresses and ports in configuration files.
* **Negative (Manageable Risks):**
    * **Resources:** Three additional JVM processes (Eureka, Config, Gateway) will consume memory, which may be noticeable on less powerful local machines.
    * **Operational Burden:** We are responsible for running and monitoring these "infra-services" ourselves.
    * **High-Load:** This stack is not designed for extremely high loads, unlike a K8s + Service Mesh setup. This is a deliberate trade-off in favor of development speed at the start.

### 5. Alternatives Considered

#### Alternative 1: Kubernetes (K8s)
* **Description:** Start immediately with "proper" infrastructure: a K8s cluster, an Ingress Controller (Nginx), and a Service Mesh (Istio/Linkerd).
* **Reason for Rejection:** **Excessive complexity (Overkill)**. This requires a dedicated DevOps team, complex CI/CD setup, and significant time investment in cluster management. It directly contradicts our goal of "rapid Time-to-Market."

#### Alternative 2: Monolith
* **Description:** Write everything in a single application.
* **Reason for Rejection:** We are deliberately choosing microservices for development flexibility and future team scaling. A monolith would quickly become a "Big Ball of Mud" and slow us down in the medium term.

#### Alternative 3: Docker Compose + Hardcoding
* **Description:** Use `docker-compose` but hardcode service names and ports in each service's `application.yml`.
* **Reason for Rejection:** Inflexible. Creates configuration chaos. Lacks centralized management. Adding a new instance of a service would require manual config edits.

---

### 6. Migration Plan (Upon Growth)

When we hire a DevOps team and are ready to transition to **Kubernetes**, our migration plan will look like this:

| Capability            | üèÅ **Current Solution (Spring Cloud)** | üöÄ **Future Solution (Kubernetes)**                |
|:----------------------|:---------------------------------------|:---------------------------------------------------|
| **Service Discovery** | `Spring Cloud Netflix Eureka`          | **K8s DNS** (internal) + `Service`                 |
| **Configuration**     | `Spring Cloud Config Server`           | **K8s ConfigMaps** & **Secrets**                   |
| **API Gateway**       | `Spring Cloud Gateway` (JVM)           | **Infra-level Ingress** (Nginx, Traefik, Contour)  |
| **Resilience**        | `Resilience4j` (in-code)               | **Service Mesh** (Istio/Linkerd) (transparent)     |

**Migration Steps (Per-Service):**

1.  **Configuration:** Add the `spring-cloud-starter-kubernetes-config` dependency. This will teach Spring Boot to read `ConfigMaps`. Decommission `Config Server`.
2.  **Service Discovery:** Replace `spring-cloud-starter-netflix-eureka` with `spring-cloud-starter-kubernetes-discovery`. K8s will handle discovery via DNS.
3.  **Gateway:** "Externalize" the `Spring Cloud Gateway` by replacing it with an Ingress Controller that operates as an L7 proxy (Go/Nginx).

**Key Takeaway:** Our business services (`user-service`, `order-service`, etc.) will require **minimal code changes**. We will simply swap the Spring Cloud "adapters" for K8s-native ones.